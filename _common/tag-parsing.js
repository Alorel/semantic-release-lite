!function(e,t,r,s,a,o,i,n,c,h,m){"use strict";const p=e("./exec.js");class l{prefixed;major;minor;patch;constructor(e,t,r,s=!0){this.prefixed=s,this.major=isNaN(e)?0:Number(e),this.minor=isNaN(t)?0:Number(t),this.patch=isNaN(r)?0:Number(r)}static parse(e,t=!1){const r=e.match(/^\s*(?<v>v)?(?<major>\d+)(\.(?<minor>\d+)(\.(?<patch>\d+))?)?\s*$/)?.groups;if(r)return new l(r.major,r.minor,r.patch,Boolean(r.v)||!t)}static async resolveLastRelease(){let e;try{e=await p.exec("git tag --list --sort=-committerdate","getting last tag",!1)}catch{return}if(e)for(const t of e.split(/\r?\n/g)){const e=l.parse(t,!0);if(e)return p.coreExports.info(`Last tag resolved to ${e}`),e}}static resolveNextRelease({lastTag:e,releaseType:t,stayAtZero:r}){return e?t?e.clone().increment(t,r):e:r?"patch"===t?new l(0,0,1):new l(0,1):new l(1)}clone(){return new l(this.major,this.minor,this.patch)}increment(e,t=!1){switch(e){case"major":t&&0===this.major?++this.minor:(p.coreExports.notice(`stay-at-zero has no effect as we're already on version ${this}`),++this.major);break;case"minor":++this.minor;break;case"patch":++this.patch;break;default:throw new c(`Unrecognised release type: ${e}`)}return this}toString(){return`${this.prefixed?"v":""}${this.major}.${this.minor}.${this.patch}`}}exports.SemVer=l}(require,Reflect,console,0,Error,JSON,Math,process,TypeError,0,Symbol);
