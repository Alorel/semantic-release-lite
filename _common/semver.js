!function(t,r,e,i,s,n,a,o,c,h,l){"use strict";const m=t("./exec.js");class p{prefixed;major;#t;#r;constructor(t,r,e,i=!0){this.prefixed=i,this.major=f(t)??0,this.#t=f(r),this.#r=f(e)}static cmp(t,r){return null==t?null==r?0:-1:null==r?-1:d(t.major,r.major)??d(t.#t,r.#t)??d(t.#r,r.#r)??0}static parse(t,r=!1){const e=t.match(/^\s*(?<v>v)?(?<major>\d+)(\.(?<minor>\d+)(\.(?<patch>\d+))?)?\s*$/)?.groups;if(e)return new p(e.major,e.minor,e.patch,Boolean(e.v)||!r)}static async resolveLastRelease(){let t;try{t=await m.exec("git tag --list","getting last tag",!1)}catch{return}if(!t)return;const r=t.split(/\r?\n/g).map((t=>p.parse(t,!0)));return r.sort(p.cmp),r[0]?(m.coreExports.info(`Last tag resolved to ${r[0]}`),r[0]):void 0}static resolveNextRelease({lastTag:t,releaseType:r,stayAtZero:e}){return t?r?t.materialise().increment(r,e):t:e?"patch"===r?new p(0,0,1):new p(0,1,0):new p(1,0,0)}get minor(){return this.#t??0}set minor(t){this.#t=t}get patch(){return this.#r??0}set patch(t){this.#r=t}increment(t,r=!1){switch(t){case"major":r&&0===this.major?++this.minor:(m.coreExports.notice(`stay-at-zero has no effect as we're already on version ${this}`),++this.major);break;case"minor":++this.minor;break;case"patch":++this.patch;break;default:throw new c(`Unrecognised release type: ${t}`)}return this}materialise(){return new p(this.major,this.minor,this.patch)}toString(){return`${this.prefixed?"v":""}${[this.major,this.#t,this.#r].filter(u).join(".")}`}}function u(t){return null!=t}function f(t){if(null!=t)return isNaN(t)?0:Number(t)}function d(t,r){return null==t?null==r?h:1:null==r||t>r?-1:t<r?1:void 0}exports.SemVer=p}(require,Reflect,console,0,Error,JSON,Math,process,TypeError,void 0,Symbol);
