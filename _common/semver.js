!function(t,r,e,i,s,a,o,n,c,h,m){"use strict";const p=t("./output-mgr.js");class l{prefixed;major;#t;#r;constructor(t,r,e,i=!0){this.prefixed=i,this.major=j(t)??0,this.#t=j(r),this.#r=j(e)}static cmp(t,r){return null==t?null==r?0:-1:null==r?-1:f(t.major,r.major)??f(t.#t,r.#t)??f(t.#r,r.#r)??0}static parse(t,r=!1){const e=t.match(/^\s*(?<v>v)?(?<major>\d+)(\.(?<minor>\d+)(\.(?<patch>\d+))?)?\s*$/)?.groups;if(e)return new l(e.major,e.minor,e.patch,Boolean(e.v)||!r)}static async resolveLastRelease(){let t;try{t=await p.exec("git tag --list","getting last tag",!1)}catch{return}if(!t)return;const r=t.split(/\r?\n/g).map((t=>l.parse(t,!0)));return r.sort(l.cmp),r[0]?(p.coreExports.info(`Last tag resolved to ${r[0]}`),r[0]):void 0}static resolveNextRelease({lastTag:t,releaseType:r,stayAtZero:e}){return t?r?t.materialise().increment(r,e):t:e?"patch"===r?new l(0,0,1):new l(0,1,0):new l(1,0,0)}get minor(){return this.#t??0}set minor(t){this.#t=t}get patch(){return this.#r??0}set patch(t){this.#r=t}computeReleaseType(t=new l(0,0,0)){return this.major>t.major?"major":this.minor>t.minor?"minor":this.patch>t.patch?"patch":void 0}increment(t,r=!1){switch(t){case"major":r&&0===this.major?++this.minor:(p.coreExports.notice(`stay-at-zero has no effect as we're already on version ${this}`),++this.major,this.minor=0),this.patch=0;break;case"minor":0!==this.major||r?++this.minor:(this.major=1,this.minor=0),this.patch=0;break;case"patch":++this.patch;break;default:throw new c(`Unrecognised release type: ${t}`)}return this}materialise(){return new l(this.major,this.minor,this.patch)}toString(){return`${this.prefixed?"v":""}${[this.major,this.#t,this.#r].filter(u).join(".")}`}}function u(t){return null!=t}function j(t){if(null!=t)return isNaN(t)?0:Number(t)}function f(t,r){return null==t?null==r?h:1:null==r||t>r?-1:t<r?1:void 0}exports.SemVer=l}(require,Reflect,console,0,Error,JSON,Math,process,TypeError,void 0,Symbol);
