!function(t,r,e,i,s,n,a,o,c,h,l){"use strict";const m=t("./output-mgr.js");class u{prefixed;major;#t;#r;constructor(t,r,e,i=!0){this.prefixed=i,this.major=f(t)??0,this.#t=f(r),this.#r=f(e)}static cmp(t,r){return null==t?null==r?0:-1:null==r?-1:g(t.major,r.major)??g(t.#t,r.#t)??g(t.#r,r.#r)??0}static parse(t,r=!1){const e=t.match(/^\s*(?<v>v)?(?<major>\d+)(\.(?<minor>\d+)(\.(?<patch>\d+))?)?\s*$/)?.groups;if(e)return new u(e.major,e.minor,e.patch,Boolean(e.v)||!r)}static async resolveLastRelease(){let t;try{t=await m.exec("git tag --list","getting last tag",!1)}catch{return}if(!t)return;const r=t.split(/\r?\n/g).map((t=>u.parse(t,!0)));return r.sort(u.cmp),r[0]?(m.coreExports.info(`Last tag resolved to ${r[0]}`),r[0]):void 0}static resolveNextRelease({lastTag:t,releaseType:r,stayAtZero:e}){return t?r?t.materialise().increment(r,e):t:e?"patch"===r?new u(0,0,1):new u(0,1,0):new u(1,0,0)}get minor(){return this.#t??0}set minor(t){this.#t=t}get patch(){return this.#r??0}set patch(t){this.#r=t}increment(t,r=!1){switch(t){case"major":r&&0===this.major?++this.minor:(m.coreExports.notice(`stay-at-zero has no effect as we're already on version ${this}`),++this.major);break;case"minor":++this.minor;break;case"patch":++this.patch;break;default:throw new c(`Unrecognised release type: ${t}`)}return this}materialise(){return new u(this.major,this.minor,this.patch)}toString(){return`${this.prefixed?"v":""}${[this.major,this.#t,this.#r].filter(p).join(".")}`}}function p(t){return null!=t}function f(t){if(null!=t)return isNaN(t)?0:Number(t)}function g(t,r){return null==t?null==r?h:1:null==r||t>r?-1:t<r?1:void 0}exports.SemVer=u}(require,Reflect,console,0,Error,JSON,Math,process,TypeError,void 0,Symbol);
